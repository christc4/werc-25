<h1><ruby>haskell-ts-mode<rt>emacs major mode</rt></ruby></h1><p>A haskell mode that uses treesitter<h2>Screenshot</h2><p><img src=ss.png style=width:220px><p>The above screenshot is indented and coloured using haskell-ts-mode, with <code>prettify-symbols-mode</code> enabled.<h2>Usage</h2><ul>    <li><code>C-c C-r</code> to open REPL    <li><code>C-c C-c</code> to send code to repl    <li><code>C-M-q</code> Indent the function</ul><h2>Features</h2><p>Say it with me: indentation does not change the syntax-tree. This means that the indentation is a lot more predictable, but sometimes you must manually press <code>M-i</code> to indent.<p>An overview of the features are:<ul>    <li>Syntax highlighting    <li>Indentation    <li>Imenu support    <li>REPL (<code>C-c r</code> in the mode to run)    <li>Prettify symbols mode support</ul><h2>Comparison with haskell-mode</h2><p>The more interesting features are:<ul>    <li>Logical syntax highlighting:        <ul>            <li>Only arguments that can be used in functions are highlighted, e.g., in <code>f (_:(a:[]))</code> only <code>a</code> is highlighted, as it is the only variable that is captured that can be used in the body of the function.            <li>The return type of a function is highlighted.            <li>All new variables are (or should be) highlighted, this includes generators, lambda args.            <li>Highlighting the <code>=</code> operator in guarded matches correctly, this would be stupidly hard in regexp-based syntax.        </ul>        <li>More performant, especially in longer files.    <li>Much less codeâ€”haskell mode has accumulated 30,000 lines of features to deal with all things Haskell-related; this mode keeps the scope to basic major mode stuff and leaves other stuff for external packages.</ul><h2>Motivation</h2><p><code>haskell-mode</code> contains nearly 30k lines of code and is about 30 years old. Therefore, a lot of stuff Emacs has gained the ability to do in those years, haskell-mode already has implemented them.<p>In 2018, a mode called <code>haskell-tng-mode</code> was made to solve some of these problems. However, because of Haskell's syntax, it too became very complex and required a web of dependencies.<p>Both these modes ended up practically parsing Haskell's syntax to implement indentation, so I thought why not use Tree-sitter?<h2>Installation</h2><p>The package is available on ELPA. You can install it using:<p><code>M-x package-install RET haskell-ts-mode RET</code><pre><code>(add-to-list 'load-path "path/to/haskell-ts-mode")(require 'haskell-ts-mode)</code></pre><h2>Customization</h2><p>If colour is too much or too less for you, adjust <code>treesit-font-lock-level</code> accordingly.<p>If you want to highlight signature declarations (disabled by default), add the following to your init file:<pre><code>(setq haskell-ts-highlight-signature t)</code></pre><h3>How to disable haskell-ts-mode indentation</h3><pre><code>(setq haskell-ts-use-indent nil)</code></pre><h3>Pretify symbols mode</h3><p><code>prettify-symbols-mode</code> can be used to replace common symbols with Unicode alternatives.<pre><code>(add-hook 'haskell-ts-mode 'prettify-symbols-mode)</code></pre><h3>Adjusting font lock level</h3><p>Set <code>haskell-ts-font-lock-level</code> accordingly. Default value is 4, so if you suffer from contagious dehydration, you can lower it.<h3>Language server</h3><p><code>haskell-ts-mode</code> now works with <code>lsp-mode</code>, but <code>lsp-haskell</code> still relies on <code>haskell-mode</code>.<p>To add <code>eglot</code> support, add the following code to your init.el:<pre><code>(with-eval-after-load 'eglot  (defvar eglot-server-programs)  (add-to-list 'eglot-server-programs'(haskell-ts-mode . ("haskell-language-server-wrapper" "--lsp"))))</code></pre><h2>TODO</h2><ul>    <li>Imenu support for functions with multiple definitions    <li>Proper indenting of multiline signatures: the Tree-sitter grammar does not flatten the signatures, rather leaves them to the standard infix interpretation. This makes indentation hard, as it will mean the only way to check if the signature node is an ancestor of the node at point is to perform a recursive ascent</ul><p>Author: <a href=//p.bauherren.ovh>Pranshu</a>
